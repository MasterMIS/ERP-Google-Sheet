
// NBD CRUD OPERATIONS

export async function getNBDs() {
  try {
    const sheets = await getGoogleSheetsClient();
    const sheetName = SHEETS.NBD;

    const response = await sheets.spreadsheets.values.get({
      spreadsheetId: NBD_SPREADSHEET_ID,
      range: `${sheetName}!A:Z`,
    });

    const rows = response.data.values;
    if (!rows || rows.length === 0) return [];

    const headers = rows[0];
    const dataRows = rows.slice(1);

    const nbds = dataRows
      .map(row => rowToObject(headers, row))
      .filter(n => n.id)
      .sort((a, b) => new Date(b.created_at || 0).getTime() - new Date(a.created_at || 0).getTime());

    return nbds;
  } catch (error) {
    console.error('Error fetching NBDs:', error);
    throw error;
  }
}

export async function createNBD(data: any) {
  try {
    const sheets = await getGoogleSheetsClient();
    const sheetName = SHEETS.NBD;

    // Check headers
    const response = await sheets.spreadsheets.values.get({
      spreadsheetId: NBD_SPREADSHEET_ID,
      range: `${sheetName}!A1:Z1`,
    });

    let headers = response.data.values?.[0] || [];

    if (headers.length === 0) {
      const defaultHeaders = [
        'id', 'party_name', 'type', 'contact_person', 'email', 'contact_no_1', 'contact_no_2',
        'location', 'state', 'stage', 'tat_days', 'field_person_name', 'remarks', 'created_at', 'updated_at'
      ];
      await sheets.spreadsheets.values.update({
        spreadsheetId: NBD_SPREADSHEET_ID,
        range: `${sheetName}!A1:O1`,
        valueInputOption: 'RAW',
        requestBody: { values: [defaultHeaders] },
      });
      headers = defaultHeaders;
    }

    // Generate ID
    const allData = await sheets.spreadsheets.values.get({
      spreadsheetId: NBD_SPREADSHEET_ID,
      range: `${sheetName}!A:A`,
    });
    const newId = (allData.data.values || []).length;

    const newNBD = {
      id: newId,
      ...data,
      created_at: formatDateTime(new Date()),
      updated_at: formatDateTime(new Date())
    };

    const rowData = objectToRow(headers, newNBD);

    await sheets.spreadsheets.values.append({
      spreadsheetId: NBD_SPREADSHEET_ID,
      range: `${sheetName}!A:Z`,
      valueInputOption: 'RAW',
      requestBody: { values: [rowData] },
    });

    return newNBD;
  } catch (error) {
    console.error('Error creating NBD:', error);
    throw error;
  }
}

export async function updateNBD(id: number, data: any) {
  try {
    const sheets = await getGoogleSheetsClient();
    const sheetName = SHEETS.NBD;

    const headersRes = await sheets.spreadsheets.values.get({
      spreadsheetId: NBD_SPREADSHEET_ID,
      range: `${sheetName}!A1:Z1`,
    });
    const headers = headersRes.data.values?.[0];
    if (!headers) throw new Error('Headers not found');

    const idRes = await sheets.spreadsheets.values.get({
      spreadsheetId: NBD_SPREADSHEET_ID,
      range: `${sheetName}!A:A`,
    });
    const ids = idRes.data.values || [];
    const rowIndex = ids.findIndex(row => parseInt(row[0]) == id);
    
    if (rowIndex === -1) throw new Error('NBD not found');
    const actualRow = rowIndex + 1;

    // Fetch existing
    const rowRes = await sheets.spreadsheets.values.get({
      spreadsheetId: NBD_SPREADSHEET_ID,
      range: `${sheetName}!A${actualRow}:Z${actualRow}`,
    });
    const existing = rowToObject(headers, rowRes.data.values?.[0] || []);

    const updated = {
      ...existing,
      ...data,
      updated_at: formatDateTime(new Date())
    };

    const rowData = objectToRow(headers, updated);

    await sheets.spreadsheets.values.update({
      spreadsheetId: NBD_SPREADSHEET_ID,
      range: `${sheetName}!A${actualRow}:Z${actualRow}`,
      valueInputOption: 'RAW',
      requestBody: { values: [rowData] },
    });

    return updated;
  } catch (error) {
    console.error('Error updating NBD:', error);
    throw error;
  }
}

export async function deleteNBD(id: number) {
  try {
    const sheets = await getGoogleSheetsClient();
    const sheetName = SHEETS.NBD;

    const idRes = await sheets.spreadsheets.values.get({
      spreadsheetId: NBD_SPREADSHEET_ID,
      range: `${sheetName}!A:A`,
    });
    const ids = idRes.data.values || [];
    const rowIndex = ids.findIndex(row => parseInt(row[0]) == id);

    if (rowIndex === -1) throw new Error('NBD not found');

    // Add 1 for 1-based index
    const actualRow = rowIndex + 1;

    await sheets.spreadsheets.batchUpdate({
      spreadsheetId: NBD_SPREADSHEET_ID,
      requestBody: {
        requests: [{
          deleteDimension: {
            range: {
              sheetId: 0, // Assumption: NBD is the first/only sheet.
              dimension: 'ROWS',
              startIndex: actualRow - 1,
              endIndex: actualRow
            }
          }
        }]
      }
    });

    return { id };
  } catch (error) {
    console.error('Error deleting NBD:', error);
    throw error;
  }
}
